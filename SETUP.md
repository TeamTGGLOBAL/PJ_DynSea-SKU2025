# Project DynSea SKU (プロジェクト ダイナシーエスケーユー)

[![Project Status: Active](https://www.repostatus.org/badges/latest/active.svg)](https://www.repostatus.org/#active)

**生鮮海産物の「データ化の壁」を打ち破り、水産業界のDXを推進するプロジェクト**

## 1. プロジェクト概要 (Overview)

**Project DynSea SKU** は、生鮮海産物特有の「不安定さ」と「不確実性」という長年の課題を、**Dynamic SKU（動的在庫管理単位）** という革新的なアプローチで解決することを目指すプロジェクトです。

漁獲から加工、流通、販売に至るまでのサプライチェーン全体で、これまで捉えきれなかった詳細な情報をデータ化し、リアルタイムに連携させることで、業界全体の効率化、収益性向上、そして持続可能性の実現を目指します。

### 解決したい課題 (Problems to Solve)

*   **データ化の困難性:** 魚種、サイズ、品質、産地など、変動要素が多すぎて規格化が難しい。
*   **SKU管理の限界:** 従来の固定的SKUでは、規格外品や日々の変動に対応しきれない。
*   **機会損失と非効率:** 在庫管理や需要予測が困難で、廃棄ロスや販売機会損失が発生。
*   **情報の不透明性:** サプライチェーン全体での情報が分断され、トレーサビリティの確保が難しい。

### 目指す未来 (Our Vision)

勘と経験に「データ」という強力な羅針盤を加え、漁師から消費者まで、全てのステークホルダーがその価値を正当に評価され、豊かになれる「データドリブンな水産業」を実現します。

## 2. システムアーキテクチャ (Architecture)

本プロジェクトは、スケーラビリティと柔軟性を重視し、クラウドネイティブな技術スタックを採用します。（※これは初期の想定であり、開発の進捗に応じて変更される可能性があります）

**(ビジュアル案：簡単なアーキテクチャ図をここに挿入)**

[理想形]
*   **フロントエンド / データ入力:** モバイルアプリ (React Native / Flutter), Webアプリケーション (React / Vue.js)
*   **バックエンド / SKU生成エンジン:** サーバーレス (AWS Lambda / Google Cloud Functions) with Node.js / Python
*   **データベース:** PostgreSQL (リレーショナルデータ), Firestore / DynamoDB (NoSQL, リアルタイムデータ)
*   **データ分析 / 可視化:** Google Data Studio / Tableau, Python (Pandas, Scikit-learn)
*   **インフラストラクチャ:** Google Cloud Platform / AWS
*   **その他:** OCR (Google Cloud Vision API), GitHub (バージョン管理), Cursor (AI駆動開発)

[プロトタイプ]
*   **フロントエンド** HTML?
*   **データ入力:** ???
*   **データベース:** Google スプレッドシート

## 3. 開発環境のセットアップ (Getting Started)

このリポジトリをローカル環境でセットアップし、開発に参加するための手順です。

### 前提条件 (Prerequisites)

*   [Node.js](https://nodejs.org/) (v18.x or later)
*   [Git](https://git-scm.com/)
*   [Cursor](https://cursor.sh/) 
*   [Google Cloud SDK](https://cloud.google.com/sdk/docs/install) / [AWS CLI](https://aws.amazon.com/cli/) (必要に応じて)

### インストール手順 (Installation)

1.  **リポジトリをクローンします:**
    ```bash
    git clone https://github.com/TeamTGGLOBAL/PJ_DynSea-SKU2025
    cd PJ_DynSea-SKU2025
    ```

2.  **依存関係をインストールします:**
    ```bash
    npm install
    ```

3.  **環境変数を設定します:**
    `.env.example` ファイルをコピーして `.env` ファイルを作成し、必要な環境変数（APIキー、データベース接続情報など）を設定してください。
    ```bash
    cp .env.example .env
    ```

4.  **開発サーバーを起動します:**
    ```bash
    npm run dev
    ```
    これで、`http://localhost:3000` で開発環境にアクセスできます。

## 4. プロジェクトのロードマップ (Roadmap)

私たちはアジャイルなアプローチでプロジェクトを推進します。

-   [x] **Phase 0: 構想・企画フェーズ**
    -   [x] 課題分析とコンセプト策定
    -   [x] ステークホルダーへのヒアリング
    -   [x] 技術調査とアーキテクチャ初期設計
-   [ ] **Phase 1: プロトタイプ開発と実証実験 (PoC) (現在進行中)**
    -   [ ] 限定された範囲でのデータ入力UI開発
    -   [ ] 基本的なDynamic SKU生成ロジックの実装 (Google Apps Script / サーバーレス関数)
    -   [ ] 協力パートナーとの現場での実証実験
    -   [ ] PoCからのフィードバック収集と分析
-   [ ] **Phase 2: MVP（Minimum Viable Product）開発**
    -   [ ] 主要機能（データ収集、SKU管理、在庫可視化）の実装
    -   [ ] データベースの本格構築
    -   [ ] パイロット導入と効果測定
-   [ ] **Phase 3: 本格展開と機能拡張**
    -   [ ] 全社・全部門への展開
    -   [ ] データ分析ダッシュボードの高度化
    -   [ ] AIによる需要予測・価格最適化機能の追加
-   [ ] **Phase 4: エコシステム構築**
    -   [ ] 外部連携APIの整備
    -   [ ] 他業種・海外市場への展開検討

詳細は [Projects](https://github.com/your-username/project-dynsea-sku/projects) ボードで管理しています。

## 5. コントリビューション (Contributing)

このプロジェクトへのコントリビューションを歓迎します！バグ報告、機能提案、プルリクエストなど、どんな形でも構いません。

貢献方法の詳細は、[`CONTRIBUTING.md`](CONTRIBUTING.md) を参照してください。
また、開発に参加する際は、[`CODE_OF_CONDUCT.md`](CODE_OF_CONDUCT.md) を遵守してください。

### ブランチ戦略

*   `main`: プロダクションブランチ。常に安定した状態を保ちます。
*   `develop`: 開発用のメインブランチ。
*   `feature/issue-number-description`: 各機能開発用のブランチ。

プルリクエストは `develop` ブランチに対して作成してください。

## 6. ライセンス (License)

このプロジェクトは [MIT License](LICENSE) の下で公開されています。

## 7. 関連ドキュメント (Related Documents)

*   [企画書・構想資料](link-to-your-document-folder)
*   [システム設計書](link-to-your-document-folder)
*   [議事録](link-to-your-document-folder)

---

**README作成のポイント**

*   **最初に結論:** プロジェクトが「何であるか」を最初に簡潔に説明します。
*   **ビジュアル:** アーキテクチャ図などを入れると、視覚的に理解が深まります。
*   **Getting Startedの具体性:** 新しい開発者が迷わず開発環境を立ち上げられるように、具体的なコマンドを記載します。
*   **ロードマップの可視化:** チェックボックスを使うことで、プロジェクトの進捗が一目で分かります。
*   **貢献への門戸を開く:** 外部の協力者や新しいチームメンバーが参加しやすいように、コントリビューションの方法を明記します。
*   **関連ドキュメントへのリンク:** READMEはあくまで入り口です。より詳細な情報は別のドキュメントにまとめ、リンクを貼ることで、情報を整理します。




はい、承知いたしました。
JSONのような階層的データをクラウドで管理し、最終的にAPI経由でスプレッドシートに落とし込むための環境・ツールの選択肢と、それぞれのメリット・デメリットを解説します。

プロジェクトの初期段階から本格的な運用まで、**段階的にスケールアップできる構成**を意識して提案します。

---

### クラウド環境・ツールの選択肢

**結論から言うと、初期段階では「Google Cloud (GCP)」のエコシステムで始めるのが最もスムーズで、将来的な拡張性も高いと考えられます。**

以下に、いくつかの選択肢をレベル別に紹介します。

---

**レベル1：PoC (実証実験)・プロトタイプ段階 - 今すぐ始められる構成**

この段階の目標は「低コスト・高速」にアイデアを検証することです。

*   **データベースの代わり:** **Google スプレッドシート**
    *   **使い方:** 1つのシートを「親（商品マスタ）」、別のシートを「子（バリアント）」「孫（ロット/動的SKU）」としてリレーションを組んで管理します。
    *   **メリット:**
        *   **完全無料**で始められる。
        *   専門知識が不要で、誰でもデータの構造を視覚的に理解しやすい。
        *   入力・編集が容易。
    *   **デメリット:**
        *   データ量が増えると極端に遅くなる。
        *   複雑な階層構造を表現しにくい（正規化はできるが、JOINが大変）。
        *   同時編集に弱く、データの一貫性を保つのが難しい。
*   **データの出し入れ（APIの代わり）:** **Google Apps Script (GAS)**
    *   **使い方:** スプレッドシートのデータを操作し、簡易的なAPI（Webアプリケーションとして公開）を作成します。
    *   **メリット:**
        *   スプレッドシートとネイティブに連携できるため、開発が非常に速い。
        *   Googleのインフラ上で動くため、サーバー管理が不要。
        *   定時実行（トリガー）などの自動化も簡単。
    *   **デメリット:**
        *   実行時間に制限があり、大量のデータを扱う処理には向かない。
        *   本格的なAPIに比べて機能やパフォーマンスに制限がある。

**▶ この構成でのデータフロー**
`現場の入力（Googleフォームなど） → スプレッドシートにデータがたまる → GASがデータを階層的に整理 → GASのWebアプリ機能を使って、必要な粒度のデータを返す`

---

**レベル2：MVP (Minimum Viable Product)・小規模運用段階 - 本格運用の土台作り**

この段階では、スプレッドシートの限界を超え、より堅牢でスケーラブルなデータ管理を目指します。

*   **データベース:** **Firestore (in Google Cloud)**
    *   **なぜFirestoreか？:** Firestoreは**ドキュメント指向のNoSQLデータベース**であり、**JSONのような階層的データ構造をそのまま保存するのに最適**です。
    *   **メリット:**
        *   スキーマレスで、柔軟にデータ構造を変更できる（新しい属性の追加が容易）。
        *   リアルタイムでのデータ同期が得意。
        *   無料枠が大きく、小規模なうちはコストを抑えられる。
        *   クライアント（Web/モバイルアプリ）から直接データを読み書きでき、開発スピードが速い。
    *   **デメリット:**
        *   複雑な集計や分析処理は、リレーショナルデータベースほど得意ではない。
*   **データの出し入れ（API）:** **Cloud Functions (in Google Cloud)**
    *   **使い方:** Firestoreのデータに対するリクエストを受け取り、ビジネスロジック（SKU生成、価格計算など）を実行して、結果をJSON形式で返すAPIを構築します。
    *   **メリット:**
        *   サーバーレスなので、サーバーの管理・運用が不要。リクエストがあった時だけ実行されるため経済的。
        *   Firestoreや他のGoogle Cloudサービスとの連携が非常にスムーズ。
        *   Node.js, Pythonなど、使い慣れた言語で開発できる。
    *   **デメリット:**
        *   コールドスタート（最初の起動に少し時間がかかる）の問題がある場合がある。

**▶ この構成でのデータフロー**
`現場の入力（Web/モバイルアプリ） → Cloud Functions (API) がリクエストを受け取る → データを整形し、Firestoreに保存 → 別のAPIリクエストに応じて、Firestoreからデータを取得し、要求された粒度で返す`

---

**レベル3：本格運用・データ分析段階 - 高度な活用を目指す**

この段階では、大量のデータを効率的に扱い、高度なデータ分析を行うための基盤を整えます。

*   **データベースの組み合わせ:**
    *   **Firestore:** リアルタイムなデータの読み書き、アプリケーションのメインDBとして引き続き利用。
    *   **PostgreSQL (Cloud SQL in Google Cloud):**
        *   **なぜ組み合わせるか？:** Firestoreに保存されたデータを、定期的にPostgreSQLに同期することで、**複雑なSQLクエリを使った集計や分析**が可能になります。
        *   PostgreSQLの**JSONB型**を使えば、JSONデータを効率的に扱いながら、リレーショナルデータの利点も享受できます。
    *   **BigQuery (in Google Cloud):**
        *   **なぜ組み合わせるか？:** さらに大量のデータ（数テラバイト級）を高速に分析したい場合、FirestoreやCloud SQLからBigQueryにデータを流し込み、データウェアハウスとして利用します。AI/機械学習モデルの構築にも最適です。
*   **データの出し入れ（API）:** **Cloud Run / App Engine (in Google Cloud)**
    *   **なぜ切り替えるか？:** Cloud Functionsよりも長時間の処理が可能で、常にAPIが待機している状態（常時稼働）にできるため、APIの応答速度が安定します。マイクロサービスアーキテクチャの構築にも向いています。

**▶ この構成でのデータフロー**
`Firestoreにリアルタイムデータがたまる → 定期的にCloud SQLやBigQueryにデータが同期される → APIは、目的に応じてFirestoreやCloud SQLからデータを取得 → BigQueryでは、データサイエンティストが高度な分析を行う`

---

### 最終的なゴール：APIからスプレッドシートへの落とし込み

どのレベルの構成であっても、最終的なアウトプットは**「RESTful API」**です。
このAPIが完成すれば、スプレッドシートへのデータ取り込みは非常に簡単になります。

*   **Google Apps Script (GAS) を利用:**
    *   スプレッドシートからGASを起動し、`UrlFetchApp`サービスを使って、構築したAPIを叩きます。
    *   APIから返ってきたJSONデータをパースし、スプレッドシートのセルに書き込みます。
    *   メニューに「最新データを取得」ボタンを追加したり、定時実行（例：毎朝6時）を設定することも可能です。

**サンプルGASコード（イメージ）**

```javascript
function fetchDataFromAPI() {
  // 構築したAPIのエンドポイント
  const apiUrl = "https://your-api-endpoint.run.app/products/PROD-HIRAME";
  
  const options = {
    'method' : 'get',
    'contentType': 'application/json',
    // 必要に応じて認証ヘッダーなどを追加
    // 'headers': { 'Authorization': 'Bearer ' + getOAuthToken() }
  };

  const response = UrlFetchApp.fetch(apiUrl, options);
  const data = JSON.parse(response.getContentText());

  // スプレッドシートを取得して書き込む
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("見積もりシート");
  
  // 例：粗い粒度のデータを書き込む
  sheet.getRange("A2").setValue(data.product_name);
  sheet.getRange("B2").setValue(data.price_range);

  // 例：中くらいの粒度のデータを書き込む
  data.variants.forEach((variant, index) => {
    sheet.getRange(3 + index, 1).setValue(variant.size);
    sheet.getRange(3 + index, 2).setValue(variant.price);
  });
}
```

### まとめと推奨

| フェーズ | データベース | API/バックエンド | メリット |
| :--- | :--- | :--- | :--- |
| **レベル1 (PoC)** | **Google スプレッドシート** | **Google Apps Script** | **超高速・低コストで検証可能** |
| **レベル2 (MVP)** | **Firestore** | **Cloud Functions** | **JSONとの親和性◎、スケーラブル** |
| **レベル3 (本格運用)** | **Firestore + Cloud SQL / BigQuery** | **Cloud Run / App Engine** | **高度な分析と安定したパフォーマンス** |

**推奨する進め方:**

1.  まずは**レベル1**から始め、データモデルの検証と現場のフィードバック収集に集中する。
2.  プロジェクトの有効性が確認できたら、**レベル2**の構成に移行し、本格的なアプリケーションの基盤を構築する。
3.  データの蓄積が進み、より高度な活用が見えてきた段階で、**レベル3**への拡張を検討する。

この段階的なアプローチにより、リスクを抑えながら、着実にプロジェクトを成長させることができます。


